dir()
getwd()

ls() muestra las funciones cargadas

source() introduce las funciones de una fuente

myfunction()
second(4)
second(4:10) rango de enteros consecutivos

x<-1 (por defecto utiliza vectores)
print(x)

tipos:
char
numeric (incluyendo Inf y NaN)
integer 1L
complex 2+3i
logical (booleano)(TRUE T FALSE F)
NA not available

attributes()

c( , , ) crea vector con contenidos
vector("numeric", length=10) crea vector con valores por defecto
coercion, implícita en vectores (todos iguales) o explícita as.numeric(x)

list() admite tipos diferentes
de hecho, hace listas de vectores

m <- matrix(nrow = 2, ncol = 3)
dim(m)
dim(m) <- c(2,3)
dimnames
las matrices se "llenan" por columnas
cbind() o rbind()

factors para datos categóricos (cualitativos) los tratará como 1,2... pero etiquetados
factor()
table()
unclass()

factor(c(),levels=c()) si no, se ordenan alfabéticamente

missing values
is.na() Nan is NA
is.nan()

Data Frames (listas, pseudotablas)
con atributos names y row.names (por defecto 1,2,...)
x <- data.frame( codi = 1:3, name = c("pepe","juan","luisa"))

names para poner nombres a los datos

read.table
read.csv
write.table

dump y dput graba varias cosas en fichero con metadatos
lee con source

dput graba un objeto en fichero
dget lee un objeto de un fichero

file
gzfile
url

[índice , admite índices calculados
[[índice , admite índices calculados
$name

data[1:3,] 3 primeras filas
nrow(data)

c() : crear un vector
list() : componer una lista
matrix() : componer una matriz

rep() : repeat
range() : rango, muestra el máximo y el mínimo


str(nombre_de_funcion) muestra el prototipo de una función



lapply : aplicar "iterativamente" una función a una lista (con posibles parámetros adicionales)
  devolviendo una lista (incluso de elementos simples) con el resultado de aplicar la función con los diferentes elementos de la lista

  puede usar funciones "anónimas", que se definenn como sin nombre en el mismo lapply

sapply : simplificación: en lugar de listas, devuelve, si puede, vectores o matrices

apply : aplicar iterativamente una función, habitualmente sobre partes (filas, columnas) de un array
  no es más rápida que un loop, pero sí más corta de escribir
  MARGIN = 1 por filas
  MARGIN = 2 por columnas
  tiene atajos: rowSums, rowMeans, colSums, colMeans

mapply (es diferente)
  aplicar funciones a conjuntos múltiples de argumentos
  permite vectorización instantánea (?)

tapply
  aplicar una función sobre subconjuntos (por clases) de un vector
  usa factors ("clasificadores")

split
  separa un vector según los factors (clasificadores) 
  es típico combinarlo con lapply : lapply(split(x,f),mean)
  o usarlo para separar dataframes
   PRACTICAR con el ejemplo de AirQuality y separar por meses
  puede separar en más de un nivel


para estudiar un objeto (función, variable, ...)
  str() muestra brevemente la estructura
  summary() presenta un resumen
  head() muestra las primeras filas

muestras y distribuciones
  sample() toma una muestra entre unos valores dados
  rnorm() genera números reales aleatorios
  rbinom() genera números enteros aleatorios
